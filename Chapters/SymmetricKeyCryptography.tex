\chapter{Symmetric-key Cryptography} % Main chapter title
\label{Symmetric-key Cryptography} % For referencing the chapter elsewhere, use \ref{Chapter1} 

%----------------------------------------------------------------------------------------

\textit{Symmetric-key} cryptography (also commonly referred to as \textit{private-key cryptography}) is a system of cryptography which
uses the same keys for both encryption of plaintext and decryption of ciphertext. The keys must be shared between the different
parties accessing and handling the information. The requirement that all (authorized) parties must have access to the secret key
is the biggest drawback of symmetric-key cryptography \cite{wiki:symmetric_key_cryptography}.     

This chapter will discuss and implement the different types of symmetric-key cryptography algorithms. 
First we will explore and implement the various classical cryptography examples (some of which are discussed in the 
\hyperref[Early Cryptography]{Early Cryptography} chapter). From there, we will continue and take a look at more complex modern-day algorithms 
and discuss their implementation. 

\section{Transposition Ciphers}

One of the simplest methods of cryptography, a transposition cipher, works by changing the ordering of the message to make it seemingly unreadable.
This is similar to an anagram but with a regular defined structure to make it easily decryptable (assuming you know the defined structure or the \textit{key}).   

Mathematically, the ciphertext will be a permutation of the original plaintext. We can use an encryption function to encrypt our plaintext and then use 
the \textit{inverse} of our encryption function to decrypt our ciphertext. A generic transposition cipher (one with no specific encryption function) 
can be expressed mathematically as follows: $$\mathlarger{P \rightarrow E, f(x)}$$

In this example, we are mapping the set $P$ containing the plaintext to the set $E$ containing the ciphertext using the encryption function $f(x)$. 
In mathematics, this would be referred to a \textit{bijection} from set $P$ to $E$. Keep in mind that while transposition ciphers certainly
are functions, we can not easily assign them a simple algebraic formula since they deal with the positions of letters rather than the letters themselves.

Decryption of the ciphertext is defined in a similar fashion, but instead we use the \textit{inverse bijection} from our ciphertext set $E$ to $P$. 
Notice that now our function $f(x)$ is inversed becoming: $f^{-1}(x)$. The algebraic expression for decryption is written as follows: 
$$\mathlarger{E \rightarrow P, f^{-1}(x)}$$

There are many different types of transposition cipher. In this section we will discuss a few of the more popular ones, 
each with their own benefits and drawbacks. 

\subsection{Rail Fence Cipher}

The \textit{rail fence cipher} (also referred to as a \textit{ZigZag} cipher) is a form of transposition cipher which arranges letters from
the plaintext in different "rails". It works by writing letters downwards and diagonally on following "rails" of an 
\textit{imaginary fence} (hence where the name of this cipher comes from). When we reach the bottom rail, we begin writing 
letters upwards. Likewise, when we reach the top rail, we begin writing letters downwards again until the whole plaintext is
written on our rail fence. For instance, if our fence has \textit{3} rails and our plaintext is:
'\textit{WE ARE DISCOVERED FLEE AT ONCE}', the ciphertext would look like so:

\begin{listing}[H]
    \begin{minted}[mathescape,
        numbersep=5pt,
        frame=lines,
        framesep=2mm]{text}
    
W . . . E . . . C . . . R . . . L . . . T . . . E
. E . R . D . S . O . E . E . F . E . A . O . C .
. . A . . . I . . . V . . . D . . . E . . . N . .
    
    \end{minted}
    \caption{Example of plaintext encrypted using the rail fence cipher. In this example, we have removed
    all whitespaces in the plaintext.}
\end{listing}

This is then read off to get the ciphertext:

\begin{minted}[mathescape,
    numbersep=5pt,
    frame=lines,
    framesep=2mm]{text}
    
WECRL TEERD SOEEF EAOCA IVDEN
\end{minted}

Decryption is done in a similar fashion by laying out the ciphertext in appropriate rails. Let's take a look at how
you go about decrypting the ciphertext above. First, we must know the height and \textit{cycle} of the ciphertext. The height
is simply the amount of rails that was used to encrypt the plaintext. A cycle is the number of letters which run from the top 
row to the bottom row and then up again, but stops before the top-most row (where a new cycle begins). The cycle can be 
written mathematically as: $$\mathlarger{2R - 2}$$ 

This simply says that each cycle is double our number of rails, minus 2. This is because, when we double our number of rails
(for going up and down) we wil have a duplicate position at the bottom row, thus we subtract $1$. We then also 
subtract $1$ since our cycle does not include the top-most row. Do note that the rail index is \textit{zero based}. This means
that the \textit{first} rail will have an index of \textit{0} and the last rail will have an index of $n - 1$.

Next, we will need to know the distance between every character on a specific rail. If we refer back to our example,
you will notice that both the top and bottom rails have the \textit{same} spacing between each character. This is because,
both the top and bottom row are where cycles connect. If you think of it as a triangle, the vertices of the triangle are
layed out on the bottom and top rows. The equation for calculating the character distance is: $$\mathlarger{C - 2R}$$

In simple terms, we are getting the \textit{distance} between our cycle and our current rail (factoring both up and
 down movements). As previously mentioned, distance patterns alternate on middle rows, this alternation is our cycle
  minus our \textit{current} character distance. This can be written mathematically as follows: $$\mathlarger{D_n = C - D_c}$$

Where $C$ is our cycle, $D_c$ is our current character distance, and $D_n$ is our new character distance.

There is one last step to calculating the character distance: handling the bottom rail. The aforementioned distance equation
will \textit{not} work for the bottom rail. Instead, if the rail is the bottom rail then the character distance is the 
cycle. In fact, the top rail is also the cycle but we don't need to manually handle that case as the equation does that for us
(since the subtraction is factored out because the rail index is \textit{0}).

Given the cycle and character distance, we can simply reconstruct the rail fence by laying out the cipher
text according to the appropriate character distance. 

Now that we have discussed the theory behind the Rail Fence cipher, we will go ahead and implement it.
First we will write the encryption function. To encrypt plaintext we need two key pieces of information:
our plaintext and the amount of rails to encrypt with. 

\begin{minted}[mathescape,
    numbersep=5pt,
    frame=lines,
    framesep=2mm]{python}
# Encryption function which takes in the plain_text and rail number.
def encrypt(plain_text, rails):
    # Create our cipher_text string and initialize to empty
    cipher_text = str()

    # TODO: Encryption

    return cipher_text
\end{minted}

As discussed previously, when encrypting, the message is laid out in rails according to the cycle. 
Therefore, we will need to calculate the cycle within our function. 
We can use the aforementioned equation to calculate the cycle. We use the \textit{max} function to 
make sure that our cycle stays above 1, it is simply a special case for an encryption with one rail.\footnote{Although 
encrypting plaintext with one rail won't yield particularly interesting results, we still make sure our algorithm can support it.}

\begin{minted}{python}
cycle = max(rails * 2 - 2, 1) # 1 is special case for 1 rail    
\end{minted}

Next we will write the letters of the plaintext to their corresponding position on the rail. 
We will iterate through every rail and layout characters which belong to that rail. 

In every iteration, we must calculate a few key pieces of data. First, we will need to know the distance between 
each character on the specific rail. As discussed, there is an alternating pattern between each character on a rail,
one for a character going down a cycle, and one for a character going up a cycle, with the top and bottom rails
having a constant spacing between characters. Since the top and bottom rails have the same spacing, if the rail
is the bottom rail, we set our distance to the cycle. Second, we will need to have a pointer variable which
keeps a reference to the current character we are looking at. This will simply be initialized to our rail (the start position
of the rail in the text). 

Laying out the letters is actually quite simply. Since we know the distance between each character, we can continue
iterating through the plaintext until our pointer is \textit{greater} than the length of our plaintext. In every iteration,
we increment the pointer by our character distance, making sure to alternate between the two distance patterns. 

Here is the iteration code along with the rest of the encryption function.

\begin{listing}[H]
    \begin{minted}[mathescape,
        numbersep=5pt,
        frame=lines,
        framesep=2mm]{python}
def encrypt(plain_text, rails):
    cipher_text = str()
    cycle = max((rails - 1) * 2, 1) # 1 is special case for 1 rail
            
    for rail in range(rails):
        ptr = rail
        character_distance = cycle - 2 * rail
                
        # Both the bottom and top rails have a (same) character distance of the cycle. 
        if rail == rails - 1:
            character_distance = cycle
        
        # While we have *something* to write
        while ptr < len(plain_text):
            cipher_text += plain_text[ptr]
            ptr += character_distance
        
            # If this is not the top or bottom rail 
            # alternate between two distance patterns
            if rail != 0 and rail != rails - 1:
                character_distance = cycle - character_distance
        
    return cipher_text
        \end{minted}
        \caption{Full implementation of encryption in the rail fence cipher.}
\end{listing}

The implementation for decryption is almost identical. Like encryption, when decrypting we must layout our ciphertext in the corresponding
rails. To do this, we can use the \textit{same} algorithm that we used for encryption. 

\begin{listing}[H]
    \begin{minted}[mathescape,
        numbersep=5pt,
        frame=lines,
        framesep=2mm]{python}
def decrypt(cipher_text, rails):
    plain_text = [''] * len(cipher_text)
    cipher_index = 0
    cycle = max((rails - 1) * 2, 1)  # 1 is special case for 1 rail
    
    for rail in range(rails):
        ptr = rail
        character_distance = cycle - 2 * rail
    
        # Both the bottom and top rails have a (same) character distance of the cycle. 
        if rail == rails - 1:
            character_distance = cycle
    
        # While we have *something* to write
        while ptr < len(plain_text):
            plain_text[ptr] = cipher_text[cipher_index]
            cipher_index += 1
                
            ptr += character_distance
            
            # If this is not the top or bottom rail
            # alternate between two distance patterns  
            if rail != 0 and rail != rails - 1:
                character_distance = cycle - character_distance
    
    return ''.join(plain_text)
        \end{minted}
        \caption{Full implementation of decryption in the rail fence cipher.}
\end{listing}

As you can see, there are only slight differences between the encryption and decryption implementations. The first difference is the
way we build our result text. When we \textit{encrypt}, we append characters to a string (which is our ciphertext). We can do this because
our ciphertext is \textit{one-dimensional}. Conversely, when we decrypt, since we are laying out characters on rails, we must preserve the order of the
fence; we can think of this as \textit{two-dimensional}. The second change, is that introduction of a second pointer variable: the \textit{cipher index}. 
This is simply used to track the current read index of the ciphertext so we know what character to read next. There are some other \textit{small} changes in 
the decryption code but those are self-explanatory so they will not be covered.

\section{Substitution Ciphers}

The Caesar Cipher, arguably the most popular form of substitution ciphers is another very simple form of cryptography. 
It works by replacing each letter by a certain number of letters up or down in the alphabet. But now, instead of 
creating our ciphertext, we read it into the plaintext.



Here is a simple example of a message encrypted using Caesar cipher with a shift offset of 3:

\begin{minted}[mathescape,
               numbersep=5pt,
               frame=lines,
               framesep=2mm]{text}

Plaintext message: 
HELLO WORLD
               
Ciphertext message:
KHOOR ZRUOG
\end{minted}

Even though the ciphertext appears to be unreadable, substitution cipher remains to be one of the weakest forms of cryptography. 
This is for several reasons:
\begin{itemize}  
    \item The possible number of keys is very small, since the key is an offset by which to shift by, it is limited to the number of letters in the alphabet.
    In the case of the English alphabet, one could very easily try all 25 possibilities. 
    \item Since the structure of the original message remains intact, the ciphertext could be subjected to frequency-analysis which would reveal patterns about the message;
    potentially revealing the key.
    \item By studying multiple different ciphertexts, one could notice patterns within them and find out the key through that.
\end{itemize}

The substitution cipher can be expressed mathematically as follows: $$\mathlarger{E_i(n)=(n+k)\mod{26}}$$

Here we say that the encryption of the $ith$ letter $n$ is equal to a shift of $n+k$ where $k$ is the shift offset (or the key). The result of the shift
is modulo divided by $26$ to make sure that if the shift goes beyond the range of the alphabet (0 to 26),  it wraps around back to the beginning.

Decryption is done in a similar manner, but instead subtracting by $k$. $$\mathlarger{P_i(n)=(n-k)\mod{26}}$$

Please note that even though this example is for the English alphabet, the aforementioned equations should work for most languages assuming that they are modified
to the count of the specific languages' alphabet.
