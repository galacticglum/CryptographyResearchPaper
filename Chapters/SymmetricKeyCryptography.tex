\chapter{Symmetric-key Cryptography} % Main chapter title
\label{Symmetric-key Cryptography} % For referencing the chapter elsewhere, use \ref{Chapter1} 

%----------------------------------------------------------------------------------------

\textit{Symmetric-key} cryptography (also commonly referred to as \textit{private-key cryptography}) is a system of cryptography which
uses the same keys for both encryption of plaintext and decryption of ciphertext. The keys must be shared between the different
parties accessing and handling the information. The requirement that all (authorized) parties must have access to the secret key
is the biggest drawback of symmetric-key cryptography \cite{wiki:symmetric_key_cryptography}.     

This chapter will discuss and implement the different types of symmetric-key cryptography algorithms. 
First we will explore and implement the various classical cryptography examples (some of which are discussed in the 
\hyperref[Early Cryptography]{Early Cryptography} chapter). From there, we will continue and take a look at more complex modern-day algorithms 
and discuss their implementation. 

\section{Transposition Ciphers}

One of the simplest methods of cryptography, a transposition cipher, works by changing the ordering of the message to make it seemingly unreadable.
This is similar to an anagram but with a regular defined structure to make it easily decryptable (assuming you know the defined structure or the \textit{key}).   

Mathematically, the ciphertext will be a permutation of the original plaintext. We can use an encryption function to encrypt our plaintext and then use 
the \textit{inverse} of our encryption function to decrypt our ciphertext. A generic transposition cipher (one with no specific encryption function) 
can be expressed mathematically as follows: $$\mathlarger{P \rightarrow E, f(x)}$$

In this example, we are mapping the set $P$ containing the plaintext to the set $E$ containing the ciphertext using the encryption function $f(x)$. 
In mathematics, this would be referred to a \textit{bijection} from set $P$ to $E$. Keep in mind that while transposition ciphers certainly
are functions, we can not easily assign them a simple algebraic formula since they deal with the positions of letters rather than the letters themselves.

Decryption of the ciphertext is defined in a similar fashion, but instead we use the \textit{inverse bijection} from our ciphertext set $E$ to $P$. 
Notice that now our function $f(x)$ is inversed becoming: $f^{-1}(x)$. The algebraic expression for decryption is written as follows: 
$$\mathlarger{E \rightarrow P, f^{-1}(x)}$$

There are many different types of transposition cipher. In this section we will discuss a few of the more popular ones, 
each with their own benefits and drawbacks. 

\subsection{Rail Fence Cipher}

The \textit{rail fence cipher} (also referred to as a \textit{ZigZag} cipher) is a form of transposition cipher which arranges letters from
the plaintext in different "rails". It works by writing letters downwards and diagonally on following "rails" of an 
\textit{imaginary fence} (hence where the name of this cipher comes from). When we reach the bottom rail, we begin writing 
letters upwards. Likewise, when we reach the top rail, we begin writing letters downwards again until the whole plaintext is
written on our rail fence. For instance, if our fence has \textit{3} rails and our plaintext is:
'\textit{WE ARE DISCOVERED FLEE AT ONCE}', the ciphertext would look like so:

\begin{listing}[H]
    \begin{minted}[mathescape,
        numbersep=5pt,
        frame=lines,
        framesep=2mm]{text}
    
W . . . E . . . C . . . R . . . L . . . T . . . E
. E . R . D . S . O . E . E . F . E . A . O . C .
. . A . . . I . . . V . . . D . . . E . . . N . .
    
    \end{minted}
    \caption{Example of plaintext encrypted using the rail fence cipher. In this example, we have removed
    all whitespaces in the plaintext.}
\end{listing}

This is then read off to get the ciphertext:

\begin{minted}[mathescape,
    numbersep=5pt,
    frame=lines,
    framesep=2mm]{text}
    
WECRL TEERD SOEEF EAOCA IVDEN
\end{minted}

Decryption is done in a similar fashion by laying out the ciphertext in appropriate rails. Let's take a look at how
you go about decrypting the ciphertext above. First, we must know the height and \textit{cycle} of the ciphertext. The height
is simply the amount of rails that was used to encrypt the plaintext. A cycle is the number of letters which run from the top 
row to the bottom row and then up again, but stops before the top-most row (where a new cycle begins). The cycle can be 
written mathematically as: $$\mathlarger{2R - 2}$$ 

This simply says that each cycle is double our number of rails, minus 2. This is because, when we double our number of rails
(for going up and down) we wil have a duplicate position at the bottom row, thus we subtract $1$. We then also 
subtract $1$ since our cycle does not include the top-most row.

Now that we have discussed the theory behind the Rail Fence cipher, let's go ahead and implement it.
First we will write the encryption function. To encrypt plaintext we need two key pieces of information:
our plaintext and the amount of rails to encrypt with. Here is our encryption function definition:

\begin{minted}{python}
# Encryption function which takes in the plain_text and rail number.
def encrypt(plain_text, rails):
    # Create our cipher_text string and initialize to empty
    cipher_text = str()

    # TODO: Encryption

    return cipher_text
\end{minted}

Now that we have defined our encryption function, we can actually start encrypting things! As discussed previously,
when encrypting, the message is laid out in rails according to the cycle. Therefore, we will need to calculate the cycle
within our function, to do this we will use the \textit{railmax} variable. The railmax variable is the max rails we can cycle,
we use the $\max$ function to make sure that railmax stays above $1$. 

\begin{minted}{python}
railmax = max((rails - 1) * 2, 1) # 1 is special case for 1 rail    
\end{minted}

Next we will write the letters of the plaintext to
their corresponding position on the rail. To do this, we use a \textit{for loop} from 0 to \textit{rails}. 

\begin{minted}{python}
for rail in range(rails):
    # TODO: Layout letters in their proper position
    pass
\end{minted}

\section{Substitution Ciphers}

The Caesar Cipher, arguably the most popular form of substitution ciphers is another very simple form of cryptography. 
It works by replacing each letter by a certain number of letters up or down in the alphabet. 

Here is a simple example of a message encrypted using Caesar cipher with a shift offset of 3:

\begin{minted}[mathescape,
               numbersep=5pt,
               frame=lines,
               framesep=2mm]{text}

Plaintext message: 
HELLO WORLD
               
Ciphertext message:
KHOOR ZRUOG
\end{minted}

Even though the ciphertext appears to be unreadable, substitution cipher remains to be one of the weakest forms of cryptography. 
This is for several reasons:
\begin{itemize}  
    \item The possible number of keys is very small, since the key is an offset by which to shift by, it is limited to the number of letters in the alphabet.
    In the case of the English alphabet, one could very easily try all 25 possibilities. 
    \item Since the structure of the original message remains intact, the ciphertext could be subjected to frequency-analysis which would reveal patterns about the message;
    potentially revealing the key.
    \item By studying multiple different ciphertexts, one could notice patterns within them and find out the key through that.
\end{itemize}

The substitution cipher can be expressed mathematically as follows: $$\mathlarger{E_i(n)=(n+k)\mod{26}}$$

Here we say that the encryption of the $ith$ letter $n$ is equal to a shift of $n+k$ where $k$ is the shift offset (or the key). The result of the shift
is modulo divided by $26$ to make sure that if the shift goes beyond the range of the alphabet (0 to 26),  it wraps around back to the beginning.

Decryption is done in a similar manner, but instead subtracting by $k$. $$\mathlarger{P_i(n)=(n-k)\mod{26}}$$

Please note that even though this example is for the English alphabet, the aforementioned equations should work for most languages assuming that they are modified
to the count of the specific languages' alphabet.
